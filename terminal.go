// Package dwellerutil provides tools to build applications for solving fallout
// related problems.
package dwellerutil

import "errors"

// TerminalAttempt tries a word on a terminal hacking puzzle.
// It takes a string slice of words, as well as the last attempted word, with
// the likeness generated by trying it in the game.
// It returns the best word to try next, along with a list of remaining options.
// It will return error if it's impossible for the options to conform to the
// attempt, or if the options provided are not formatted correctly
func TerminalAttempt(options []string, attempt string, likeness int) (string, []string, error) {
	// remove any words that don't match the likeness of attempt, and attempt
	for i := len(options) - 1; i > -1; i-- {
		indevLikeness, err := checkLikeness(options[i], attempt)
		if err != nil {
			return "", []string{}, errors.New("Words of diferent length provided")
		}
		if indevLikeness != likeness || options[i] == attempt {
			options = append(options[:i], options[i+1:]...)
		}
	}
	// it looks like the attempt is the only option
	if len(options) == 0 {
		return attempt, options, nil
	}
	return TerminalSuggest(options)
}

// TerminalSuggest takes a slice of strings of possible words and returns a string
// representing the best word to be tried next. Most often Suggest should only
// be called to generate the first attemp, and checking the attempt should
// be don with a call to Attempt
func TerminalSuggest(options []string) (best string, remaining []string, err error) {
	// there is only one option left
	// alternativly there are two left, at that point our choice doesn't matter
	if len(options) < 1 {
		return "", options, errors.New("No options given")
	}
	if len(options) <= 2 {
		return options[0], options, nil
	}
	// get a list of each position-letter pair frequency
	scores := generateScores(options)

	// use the scores to optamize the next choice
	best = optamize(options, scores)

	// return the best choice, and the options this allows
	return best, options, nil
}

// BUG(jonjmz): We need proof optamize will always solve the problem in
// four tries or less

// optamize selects the word most simalar to all the other words.
// It does so in a linear fasion, that is every letter-location match  is
// treated with the same weight as every other letter location match.
//
// I havn't proved that this is the best solution (to myself or anybody), but
// it seems like it solves every puzzle generated in game in at most 4 tries.
// If it really does, then there is no need for further optamizations
func optamize(words []string, scores []map[rune]int) string {
	bestWord := ""
	bestScore := -1
	for _, word := range words {
		temp := 0
		for i, r := range word {
			// Add to the words current score, the value of havving each of
			// the letters it has in their specific location
			temp += scores[i][r]
		}
		if temp > bestScore {
			bestScore = temp
			bestWord = word
		}
	}
	return bestWord
}

// generateScores creates a slice of maps of scores, that coincide with the
// frequency of a rune r in the nth position, where n is the index of the list
// and r is the key of the score for that rune
func generateScores(options []string) []map[rune]int {
	// Initalize out horrible score structure
	scores := make([]map[rune]int, len(options[0]), len(options[0]))
	for i := range scores {
		scores[i] = make(map[rune]int)
	}
	for _, option := range options {
		for i, r := range option {
			_, ok := scores[i][r]
			if ok {
				scores[i][r]++
			} else {
				scores[i][r] = 0
			}
		}
	}
	return scores
}

// checkLikeness checks how many instances of a same letter in the same location
// occurs between the the first and second provided word.
// It returns an error if the words are not the same length
func checkLikeness(first string, second string) (int, error) {
	if len(first) != len(second) {
		return 0, errors.New("Inconsistant Sizes")
	}
	counter := 0
	for i := range first {
		if first[i] == second[i] {
			counter++
		}
	}
	return counter, nil
}
